import featureExtractorsBasic
import porter2
import re
import samples
import util
import random

'''
-----------------------------
FEATURE EXTRACTORS FOR DIGITS
-----------------------------
'''

class DigitFeatureExtractor(featureExtractorsBasic.FeatureExtractor):
    '''
    Handles digit data.  Expects datum to be of type samples.DigitDatum
    '''
    def extractFeatures(self, datum):
        """
        Returns a set of pixel features indicating whether
        each pixel in the provided datum is white (0) or gray/black (1)
        """
        assert isinstance(datum, samples.DigitDatum), 'Expects datum to be a digit!'
        a = datum.getPixels()

        features = util.Counter()
        for x in range(datum.width):
            for y in range(datum.height):
                if datum.getPixel(x, y) > 0:
                    features[(x,y)] = 1
                else:
                    features[(x,y)] = 0
        return features

class EnhancedDigitFeatureExtractor(DigitFeatureExtractor):
    def extractFeatures(self, datum):
        """
        Your feature extraction playground.

        You should return a dictionary or a util.Counter() of features
        for this datum (datum is of type samples.Datum).
        """
        features = DigitFeatureExtractor.extractFeatures(self, datum)
        "*** YOUR CODE HERE ***"
        width = datum.width
        height = datum.height
        # feature 1. traverse from a black pixel and
        # see if the entire black pixels are accessible in one piece.
        # would help finding (4), 6, 8, 9, 0
        # RESULT: 
        # - does not work in perceptron(81.6% -> 77.7%)
        """"""
        whitePixels = set()
        for pix in features.keys():
            if features[pix] == 0:
                whitePixels.add(pix)
        startPix = random.sample(whitePixels, 1)[0]
        pixQueue = util.Queue()
        pixQueue.push(startPix)
        visited = set()
        while not pixQueue.isEmpty():
            tmp = pixQueue.pop()
            if tmp in visited:
                continue
            visited.add(tmp)
            whitePixels.remove(tmp)
            xx, yy = tmp
            for pxcrd in [(xx-1,yy),(xx+1,yy),(xx,yy-1),(xx,yy+1)]:
                if pxcrd in whitePixels:
                    pixQueue.push(pxcrd)
        if whitePixels:
            features['divided'] = 1
        else:
            features['divided'] = 0
        """"""

        # feature 2. Is there a straight vertical line
        # would help finding 1 and (4 vs 9) case, 
        """"""
        lines = [sum(datum.getPixel(x, y) for y in range(height)) for x in range(width)]
        lineLenVert = (height * 7) / 10
        if max(lines) >= lineLenVert:
            features['vertline'] = 1
        else:
            features['vertline'] = 0
        """"""

        # feature 3. Is there a straight horizontal line
        # would help finding 2, 5, 7 case, 
        """"""
        lines = [sum(datum.getPixel(x, y) for x in range(width)) for y in range(height)]
        lineLenHor = (height * 6) / 10
        if max(lines) >= lineLenHor:
            features['horline'] = 1
        else:
            features['horline'] = 0
        """"""
        "*** [END] YOUR CODE HERE ***"
        return features

'''
-----------------------------
FEATURE EXTRACTORS FOR EMAIL
-----------------------------
'''

def numCaps(s):
    '''
    Counts the number of capital letters in s.
    '''
    all_caps = 0
    for ch in s:
        if ch == ch.upper():
            all_caps += 1
    return all_caps

class EmailFeatureExtractor(featureExtractorsBasic.FeatureExtractor):
    def __init__(self):
        self.capCounts = []
        self.n = 0

    def preProcess(self, datum):
        '''
        Counts number of capitalized letters
        '''
        assert isinstance(datum, str), 'Expects datum to be a string!'
        count = numCaps(datum)
        self.capCounts.append(count)
        self.n += 1

    def finalizeFeatures(self):
        '''
        Analyzes distributions of caps and records the 25%, 50% and 75% percentiles.
        '''
        self.capCounts.sort()
        
        self.capThresholds = (self.capCounts[self.n/4], self.capCounts[self.n/2], self.capCounts[3*self.n/4])
        print 'The 25%, 50%, and 75% percentile number of capitalized letters is', self.capThresholds

    def extractFeatures(self, datum):
        '''
        Assigns a feature based on the number of capitalized letters in the email.

        All features are binary.
        '''
        assert isinstance(datum, str), 'Expects datum to be a string!'
        features = util.Counter()

        count = numCaps(datum)
        p25, p50, p75 = self.capThresholds
        if count <= p25:
            features['fewCaps'] = 1.0
        elif count <= p50:
            features['someCaps'] = 1.0
        elif count <= p75:
            features['manyCaps'] = 1.0
        else:
            features['allCaps'] = 1.0

        return features


def regexprep(text, pattern, repl):
    '''
    Finds occurrences of regular expression pattern 
    in text and replaces them with repl.  Just a 
    wrapper for re.sub but also serves as a hint that 
    this might be a useful thing to use in processing email!
    '''
    return re.sub(pattern, repl, text)


class EnhancedEmailFeatureExtractor(featureExtractorsBasic.FeatureExtractor):
    '''
    Your enhanced email extractor here.

    extractFeatures should return a dictionary or a util.Counter() of features
    for this datum (datum is of type string, representing the body of the email).


    Hint: you might find it handy to use functions regexprep and porter2.stem.
    '''

    def __init__(self):
        "*** YOUR CODE HERE ***"
        util.raiseNotDefined()

    def preProcess(self, datum):

        "*** YOUR CODE HERE ***"
        util.raiseNotDefined()

    def finalizeFeatures(self):

        "*** YOUR CODE HERE ***"
        util.raiseNotDefined()

    def extractFeatures(self, datum):

        "*** YOUR CODE HERE ***"
        util.raiseNotDefined()

