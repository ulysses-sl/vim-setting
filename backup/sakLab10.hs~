import Data.List

fixlist [] = []
fixlist (hd:tl) = hd:(fixlist (filter (/= hd) tl))

tupSubst a (b,c) = (a,c)
makeReflex r = (fst r, fst r)

comp (s,r) = if (s == [] || r == [])
               then []
               else sort (fixlist (map (\t -> tupSubst (fst (head r)) t)
                                  (filter (\rel -> snd (head r) == fst rel) s)
                                  ++ comp (s, tail r)))

mspec1 a s =
    if a == 'a'
        then (s + 1) `mod` 4
        else s

{-
*Main> mspec1 'a' 0
1
*Main> mspec1 'a' 3
0
*Main> mspec1 'b' 3
3
-}

monext f bin e [] = e
monext f bin e (hd:tl) = bin ((f hd), (monext f bin e tl))

add (x,y) = x + y
double x = 2 * x

{-
*Main> monext double add 0 [3, 4, 7]
28
-}

cmp (x,y) = x y
fsm spec string state = monext spec cmp state string

fsm1 = fsm mspec1

{-
*Main> fsm1 "abbababbaba" 0
1
*Main> fsm1 "abbababbababba" 0
2
*Main> fsm1 "abbababbababba" 1
3
-}

lm mspec str = fsm mspec str 0

{-
*Main> lm mspec1 "abbababbaba"
1
*Main> lm mspec1 "abbababbababba"
2
-}

mmspec1 = (mspec1, [0,2])

orx (a,b) = a || b
inlist x l = monext (\y -> y == x) orx False l

{-
*Main> inlist 1 [1,2,3,4]
True
*Main> inlist 1 [2,3,4]
False
-}

mm (mspec, finalstates) str = inlist (lm mspec str) finalstates

mm1 = mm mmspec1

{-
*Main> mm1 "abbababbaba"
False
*Main> mm1 "abbababbababba"
True
-}
