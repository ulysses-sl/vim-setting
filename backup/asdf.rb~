def mergesort(arr1)
    #implementation of bottom-up two-array-swap merge sort
    #basically, start by pairing indices 1:1 from the beginning.
    #then step up to 2:2, 4:4 until (step > length)
    
    length = arr1.length
    return arr1 if length < 2
    # make a copy, since mergesort needs O(n) space
    arr2 = arr1[:]
    step = 1
    while step < length
      i, curr = 0, 0  # beginning of each pair, current write point
      while i + step < length
        left, right = i, i + step #left, right are starting points of each pair
        while curr < length and curr < i + 2 * step #curr is running pointer
          if right == length or right == i + 2 * step #when you copy everything on right side but still has one on left side, eg 4 vs 3 
            arr2[curr] = arr1[left]
            left += 1
          elsif left == i + step #when running out on left side, start copy right side
            arr2[curr] = arr1[right]
            right += 1
          elsif arr1[left] <= arr1[right] #normal instance. Whenever something is smaller then copy the smaller one
            arr2[curr] = arr1[left]
            left += 1
          elsif arr1[left] > arr1[right] #same with line 22
            arr2[curr] = arr1[right]
            right += 1
          end
          curr += 1 #anytime done with an if/elsif, increment curr
        end
        i += 2 * step
      end
        # important: copy the untouched end to the new array. It's not applied yet
      while curr < length #the tail
        arr2[curr] = arr1[curr]
        curr += 1
      end
      step *= 2
      # swap two arrays for cost efficiency
      arr1, arr2 = arr2, arr1
    end
    return arr1
end

    
a = []
9.times do a<<rand(20)
end

print a
print mergesort(a)
